
Προγραμματισμός Συστήματος - 1η εργασία - Εαρινό Εξάμηνο 2020

**********
* Γενικά *
**********
Έχουν υλοποιηθεί όλα τα ζητούμενα της άσκησης σε C και σε όλα τα πηγαία αρχεία υπάρχει εκτενής σχολιασμός.

***********************
* Διαχωρισμός Αρχείων *
***********************

Ο πηγαίος κώδικας (./src/) μοιράζεται σε 3 καταλόγους:

================================================================================
>>> ./modules : Υλοποιήσεις των δομών δεδομένων.

> avl.h/.c : Το Balanced Binary Search Tree, υλοποιημένο ως AVL tree.

> hash_table.h/.c : Ο πίνακας κατακερματισμού, υλοποιημένος με seperate chaining.

> binary_heap.h/.c : Ο δυαδικός σωρός, υλοποιημένος με δέντρο από δείκτες.

================================================================================
>>> ./core : Υλοποίηση των λειτουργιών/εντολών της εφαρμογής.

> patients.h/.c : Υλοποίηση των αρχείων ασθενών καθώς και των εντολών που απαιτούν ενημέρωση/εισαγωγή ή απαρίθμησή τους. (insertPatientRecord, recordPatientExit, numCurrentPatients)

> stats.h/.c : Υλοποίηση των εντολών της εφαρμογής που εξάγουν στατιστικά από τη βάση δεδομένων. ( topk*, globalDiseaseStats, diseaseFrequency)

> helpers.h/.c : Βοηθητικές συναρτήσεις για τις λειτουργίες του stats.c. Αποτελούν τον κορμό για λειτουργίες που απαιτούν συγκεκριμένο εύρος, καθώς και για τις topk ανεξαρτήτου εύρους.

================================================================================
>>> ./tools : Υλοποιήσεις βοηθητικών λειτουργιών.

> global_vars.h : Καθολικές μεταβλητές της εφαρμογής. Πρόκειται για τους 3 πίνακες κατακερματισμού, που χρησιμοποιούνται από *σχεδόν όλες* τις λειτουργίες.

> date.h/.c : Συναρτήσεις χειρισμού των ημερομηνιών που δίνονται και επεξεργάζονται από την εφαρμογή.

> interface.h/.c : Η διεπαφή της εφαρμογής. Δέχεται το input του χρήστη, ελέγχει για σφάλματα στη σύνταξη των εντολών και καλεί κατάλληλα της ζητούμενες λειτουργίες.

> utilities.h/.c : Περιλαμβάνει την επεξεργασία των ορισμάτων της γραμμής εντολών, την προετοιμασία και την καταστροφή των δομών, καθώς και το διάβασμα από αρχείο για την προετοιμασία της βάσης.

================================================================================

*****************************
* Υλοποίηση Δομών Δεδομένων *
*****************************

Γενικά, είναι generic δομές που αποθηκεύουν οποιονδήποτε τύπο δεδομένων (μέσω δεικτών). Έχουν υλοποιηθεί όλες οι λειτουργίες που απαιτούνται για την εφαρμογή.

>>> AVL Tree

Έχουν υλοποιηθεί οι λειτουργίες δημιουργίας, καταστροφής, εισαγωγής, αναζήτησης και διάσχισης. Tα στοιχεία ταξινομούνται με μια συνάρτηση σύγκρισης και καταστρέφονται με μια συνάρτηση καταστροφής. Και οι 2 αυτές συναρτήσεις δίνονται στο δέντρο κατά τη δημιουργία του. Επίσης, κρατάμε το μέγεθος του δέντρου στο struct του, ώστε να έχουμε πρόσβαση σε αυτό σε χρόνο Ο(1). Πρέπει να σημειωθεί ότι σε αυτήν την υλοποίηση, όλα τα δεδομένα που παρέχονται *πρέπει* να είναι διαφορετικά (με βάση την διάταξη σύγκρισης που παρέχεται).

>>> Hash Table

Έχουν υλοποιηθεί οι λειτουργίες δημιουργίας, καταστροφής, εισαγωγής, αναζήτησης και διάσχισης. Το Hash Table ουσιαστικά αποτελείται από έναν πίνακα με buckets. Κάθε bucket (εαν είναι γεμάτο) συνδέεται με ένα ξεχωριστό bucket, σχηματίζοντας μια μορφή λίστας. Με αυτόν τον τρόπο υλοποιείται το seperate chaining. Κάθε bucket αποτελείται από έναν αριθμό entries (ο οποίος καθορίζεται από το bucket size). Ένα entry περιλαμβάνει από το δεδομένο που θέλουμε να αποθηκεύσουμε, καθώς και το κλειδί που συσχετίζεται με αυτό.
Στην υλοποίηση της εισαγωγής και της αναζήτησης στοιχείων στο Hash Table, έχει ληφθεί υπόψιν το γεγονός ότι τα στοιχεία *δεν* διαγράφονται (δεν υπάρχει λειτουργία διαγραφής, παρά μόνο κατά την καταστροφή).
Παρέχεται μια hash function για κλειδιά-strings που είχα χρησιμοποιήσει σε μια παλιότερη εργασία και μάλλον είχα δει στο stack overflow.

>>> Binary Heap

Έχουν υλοποιηθεί οι λειτουργίες δημιουργίας, καταστροφής, εισαγωγής, αφαίρεσης ρίζας. Tα στοιχεία ταξινομούνται με μια συνάρτηση σύγκρισης και καταστρέφονται με μια συνάρτηση καταστροφής. Και οι 2 αυτές συναρτήσεις δίνονται στο δέντρο κατά τη δημιουργία του. Έχουν χρησιμοποιηθεί μερικά βοηθητικά πεδία, όπως ο κόμβος `last` στη δομή του δέντρου, για Ο(1) πρόσβαση στον τελευταίο κόμβο, και το πεδίο `prev` στη δομή του κόμβου δέντρου, για Ο(1) διαγραφή φύλλου.
Γενικά, η υλοποίηση προσφέρει Ο(logn) χρόνο διαγραφής της ρίζας, και Ο(logn) εισαγωγή στοιχείου με Ο(1) *amortized* complexity της ίδιας λειτουργίας.

================================================================================

****************************************
* Δομών Δεδομένων που χρησιμοποιήθηκαν *
****************************************

>>> Από την εκφώνηση:

1) diseaseHashTable έχοντας ως key το `disease` και ως δεδομένo ένα `AVL Tree`, το οποίο έχει ως δεδομένα τους ασθενείς που νοσούν από αυτό το `disease`, ταξινομημένους ως προς το `entry date` τους.

2) countryHashTable έχοντας ως key το `country` και ως δεδομένo ένα `AVL Tree`, το οποίο έχει ως δεδομένα τους ασθενείς που νοσούν σε αυτό το `country`, ταξινομημένους ως προς το `entry date` τους.

3) on-the-fly binary heap, έχοντας ως key είτε το `country` είτε το `disease` και ως δεδομένο ένα ακέραιο άθροισμα ασθενών, που προκύπτει διαφορετικά ανάλογα με τη λειτουργία.

****
  Χειρισμός duplicate ημερομηνιών εισαγωγής στα AVL Trees.
****

Όπως αναφέρθηκε στις προδιαγραφές του AVL Tree, όλα τα δεδομένα πρέπει να είναι διαφορετικά μεταξύ τους. Ωστόσο, είναι προφανές ότι μπορεί να υπάρχουν εγγραφές ασθενών με την ίδια ημερομηνία εισαγωγής. Για να αντιμετωπιστεί αυτό το ζήτημα, κατά τον χειρισμό των ημερομηνιών και τη μετατροπή τους από strings σε structs, η εφαρμογή αναθέτει μια μοναδική τιμή σε κάθε ημερομηνία εισαγωγής που αντιστοιχεί σε *πραγματική* εγγραφή. Με αυτόν τον τρόπο, όλες οι ημερομηνίες εισαγωγής είναι διαφορετικές μεταξύ τους, εαν ληφθεί υπόψιν αυτό το πεδίο κατά τη σύγκριση. (Να σημειωθεί ότι το εύρος της μοναδικής αυτής τιμής κυμαίνεται από 1 μέχρι 2^64-2, οπότε δεν υπάρχει καμία [ρεαλιστική] περίπτωση να μην επαρκεί για όλους τους ασθενείς της βάσης.)

>>> Επιπλέον δομές (+2 Hash Tables):

4) patientHashTable έχοντας ως key το `recordID` και ως δεδομένο μια εγγραφή ασθενή, ώστε η αναζήτηση duplicate ασθενών και η αναζήτηση του ασθενή για την λειτουργία `/recordPatientExit` να γίνονται στον βέλτιστο δυνατό χρόνο, σε Ο(1) average.

5) Βοηθητικό Hash Table για τις λειτουργίες topk, και πιο συγκεκριμένα, για το setup του Binary Heap. Περισσότερα για τη χρήση του στην περιγραφή του αλγορίθμου. Να σημειωθεί ότι είναι και αυτό on-the-fly, με lifetime όσο αυτό της λειτουργίας topk. 

================================================================================

*************************************
* Αλγόριθμοι εξαγωγής αποτελεσμάτων *
*************************************

Οι ουσιαστικοί αλγόριθμοι για την αποδοτική εξαγωγή αποτελεσμάτων είναι 3 και βρίσκονται στο αρχείο ./core/helpers.c .

1) get_diseased_range : Εύρεση αριθμού ασθενών σε εύρος ημερομηνιών.

Επιστρέφει τον αριθμό των ασθενών που έχουν καταγραφεί σε ένα συγκεκριμένο εύρος ημερομηνιών εισαγωγής και έχουν κάποια κοινή ιδιότητα (πχ. νοσούν από την ίδια ασθένεια).

Έστω ότι το εύρος είναι [Χ1, Χ2]. Αρχικά αναζητείται κάποια εγγραφή με ημερομηνία εισαγωγής X1. 
Αν δεν βρεθεί τέτοια εγγραφή, τότε γνωρίζουμε ποιά είναι η αμέσως επόμενη εγγραφή, δηλαδή η 1η εγγραφή στο ζητούμενο εύρος. Σε κάθε περίπτωση, αφού έχει βρεθεί η πρώτη εγγραφή, διασχίζεται σειριακά το AVL Tree μέχρι να βρεθεί κάποια εγγραφή η οποία θα έχει μεταγενέστερη ημερομηνία εισαγωγής από τη Χ2. Καθ'όλη τη διάσχιση, απαριθμούνται οι κόμβοι που συναντώνται (και πληρούν τυχών περιορισμούς που έχουν τεθεί), και επιστρέφεται το σύνολό τους.

2) set_bh_range : Σύνθεση Binary Heap με αριθμούς ασθενών σε εύρος ημερομηνιών.

Φτιάχνει ένα Binary Heap με ζευγάρια <πεδίο>-<αριθμός ασθενών>, όπου το πεδίο μπορεί να είναι `disease` ή `country` και όπου όλοι οι ασθενείς έχουν ένα συγκεκριμένο εύρος ημερομηνιών εισαγωγής.

Η αναζήτηση στο AVL Tree για τους κόμβους που ανήκουν στο εύρος γίνεται με τον ίδιο τρόπο που περιγράφτηκε στο (1). Εδώ, δημιουργείται ένα προσωρινό Hash Table, με key το <πεδίο> που δόθηκε και ως δεδομένο τον αριθμό εμφάνισης του <πεδίου> στις εγγραφές που διαβάζονται. Για κάθε εγγραφή που διαβάζεται από το AVL, εαν υπάρχει το κλειδί της στο Hash Table, τότε αυξάνεται ο αριθμός που συνοδεύει το κλειδί, διαφορετικά το κλειδί εισάγεται στο Hash Table με αριθμό εμφάνισης 1. Στο τέλος αυτής της διαδικασίας, το Hash Table περιλαμβάνει όλα τα στοιχεία που θα πρέπει να εισαχθούν στο Binary Heap.

Με αυτόν τον τρόπο, περιορίζουμε την αναζήτησή μας για τις topk λειτουργίες σε 1 μόνο AVL Tree, από το οποίο εισάγουμε και αναζητούμε στοιχεία στο Hash Table σε Ο(1), και τέλος εισάγουμε όλα τα στοιχεία στο Binary Heap.

3) set_bh_no_range : Σύνθεση Binary Heap με αριθμούς ασθενών.

Όμοιο με το (2), με τη διαφορά ότι δεν ψάχνουμε ένα εύρος κόμβων στο AVL Tree, αλλά το διασχίζουμε ολόκληρο, hashάρουμε, και εισάγουμε στο Binary Heap.

================================================================================
// EOF
