
Προγραμματισμός Συστήματος - 2η εργασία - Εαρινό Εξάμηνο 2020

Γενικά: Έχουν υλοποιηθεί όλα τα ζητούμενα της άσκησης σε C και σε όλα τα αρχεία υπάρχει εκτενής σχολιασμός.

Δομή αρχικού καταλόγου:
-----------------------
> Makefile
> README.txt
> sample_data/ : Αρχεία χωρών/ασθενειών για ορίσματα στο bash script.
> create_infiles.sh : Bash script (ερώτημα Β)
> src/ : Πηγαίος κώδικας του ερωτήματος Α


Περιεχόμενα README.txt:
-----------------------
> Ερώτημα Α
>>> Δομή αρχείων και καταλόγων
>>> Παραδοχές / Σημειώσεις
>>> Επικοινωνία Πατέρα-Παιδιών
>>> Χειρισμός σημάτων
> Ερώτημα Β


---------------------------
| Σχετικά με το ερώτημα Α |
---------------------------

Compile: $ make

******************************
* Δομή αρχείων και καταλόγων *
******************************

Ο πηγαίος κώδικας (./src/) περιλαμβάνει το κοινό header file για Master και Worker: <header.h>,
καθώς και τους ακόλουθους 4 καταλόγους:

================================================================================

1) ./modules : Υλοποιήσεις των δομών δεδομένων της εφαρμογής (Hash Table, AVL Tree, Linked List)

////////////////////////////////////////////////////////////////////////////////

2) ./tools : Υλοποιήσεις βοηθητικών λειτουργιών.

> ipc.c : Συναρτήσεις επικοινωνίας μεταξύ Master και Worker. Εδώ ορίζεται το *πρωτόκολλο επικοινωνίας* μεταξύ γονέα-παιδιών.

> fifo_dir.c : Συναρτήσεις δημιουργίας named pipe και διαγραφής flat καταλόγου.

> date.c : Συναρτήσεις χειρισμού των ημερομηνιών που δίνονται και επεξεργάζονται από την εφαρμογή.

////////////////////////////////////////////////////////////////////////////////

3) ./master : Υλοποίηση του πατέρα & συντονιστή της εφαρμογής (Master)

> master.c : Η main του συντονιστή.

> setup_workers.c : Συναρτήσεις δημιουργίας των Workers και ανάθεσης αρχικών καταλόγων-χωρών.

> m_queries.c : Διαχείρηση των αιτημάτων του χρήστη. Ανάλογα με το αίτημα, είτε το προωθεί στους Workers είτε το ικανοποιεί ο ίδιος.

> validation.c : Έλεγχος εισόδου εντολών χρήστη και ορισμάτων γραμμής εντολών.


***** ./master/signals/ : Κατάλογος για τη διαχείρηση των σημάτων από τον γονέα.

>> sig_manage.c : Συναρτήσεις σχετικά με το setup, το block/unblock και catch των σημάτων.

>> sig_actions.c : Συναρτήσεις χειρισμού των σημάτων. Περιέχει τις δράσεις που θα εκτελεστούν ανάλογα με το σήμα που λήφθηκε.

////////////////////////////////////////////////////////////////////////////////

4) ./worker : Υλοποίηση του παιδιού-εργάτη της εφαρμογής (Worker)

> worker.c : Η main του εργάτη.

> signal_handling.c: Συναρτήσεις σχετικά με το setup, το block/unblock και catch των σημάτων.


***** ./worker/file_io : Κατάλογος με συναρτήσεις επεξεργασίας αρχείων και καταλόγων που χειρίζεται ο εργάτης.

>> file_parse.c : Αρχικοποίηση της βάσης δεδομένων με δεδομένα που παρέχονται από αρχείο.

>> io_files.c : Περιλαμβάνει το αρχικό διάβασμα ολόκληρων καταλόγων, τον έλεγχο για νεα αρχεία σε καταλόγους και τη δημιουργία και καταγραφή των log files.


***** ./worker/queries/ : Κατάλογος για τη διαχείρηση των δεδομένων που λαμβάνει ο εργάτης, ώστε να μπορεί να τα αποθηκεύσει, να τα επεξεργαστεί και να απαντήσει σε ερωτήματα.
Πρόκειται ουσιαστικά για τον κορμό της 1ης εργασίας, με μερικές αλλαγές προκειμένου να είναι συμβατή με τα ζητούμενα της 2ης.

================================================================================

**************************
* Παραδοχές / Σημειώσεις *
**************************

1) Οι συμβολοσειρές των χωρών και των ασθενειών που επεξεργάζεται η εφαρμογή έχουν μέγιστο μήκος 32 χαρακτήρων (post @199 στο Piazza (G.Panagiotopoulos)). Επομένως, το μέγεθος όλων των στατικών buffer της εφαρμογής έχει επιλεγεί με βάση αυτό ως δεδομένο.

2) Όταν ένα ερώτημα του χρήστη δεν έχει αποτέλεσμα (πχ. /searchPatientRecord με record id που δεν υπάρχει), τότε δεν εκτυπώνεται τίποτα στο stdout.

3) Ο πατέρας επεξεργάζεται μόνος του τα queries: /listCountries, /topk-AgeRanges. Για όλα τα υπόλοιπα, χρησιμοποιεί τους Workers.

4) Ορισμός των μετρητών success/fail:

>>> Στον πατέρα: success όταν η εντολή του χρήστη είναι έγκυρη (περνάει τον έλεγχο ορισμάτων), αλλιώς fail. Επίσης, fail μπορεί να έχουμε όταν ένα παιδί τερματίσει ξαφνικά (πχ. SIGKILL) πριν ο πατέρας τελειώσει την επεξεργασία της εντολής του χρήστη.

>>> Στο παιδί: success όταν μια εγγραφή που διαβάζεται από το αρχείο είναι έγκυρη, διαφορετικά fail.

5) Εαν ένα παιδί τερματίσει ξαφνικά, ο χρήστης ενημερώνεται ότι το αποτέλεσμα της τελευταίας εντολής του μπορεί να μην είναι έγκυρο.


******************************
* Επικοινωνία Πατέρα-Παιδιών *
******************************

Πατέρας -> Master
Παιδί   -> Worker

>> Pipes και flags ανοίγματος

Η επικοινωνία του πατέρα με τα παιδιά γίνεται μέσω 2 named pipes (όπως στο σχήμα της εκφώνησης), τα οποία δημιουργεί ο πατέρας. Μέσω των ορισμάτων της exec, μεταβιβάζει το άκρο ανάγνωσης και το άκρο εγγραφής στα παιδιά που δημιουργεί με συνδιασμό fork/exec. Τέλος, ο πατέρας και τα παιδιά ανοίγουν τα άκρα που τους αντιστοιχούν, εδραιώνοντας το μέσο επικοινωνίας.

Να σημειωθεί ότι ο πατέρας ανοίγει και τα 2 άκρα με O_NONBLOCK, ενώ το παιδί ανοίγει το άκρο εγγραφής με Ο_NONBLOCK και το άκρο ανάγνωσης με μπλοκάρισμα. Με αυτόν τον τρόπο, κανείς δεν μπλοκάρεται όταν έχει δεδομένα να γράψει στο pipe. Ο πατέρας μπλοκάρει στη select όταν δεν υπάρχουν δεδομένα να διαβάσει (οπότε δεν τον επηρεάζει το Ο_NONBLOCK του read end), ενώ το παιδί μπλοκάρει στη read σε αντίστοιχη περίπτωση.

>> Πρωτόκολλο επικοινωνίας / Κωδικοποίηση μηνυμάτων (ipc.h / ipc.c)

Τα μηνύματα που ανταλλάσονται ανάμεσα στον πατέρα και στο παιδί είναι κωδικοποιημένα, προκειμένου *να μειωθεί το μέγεθός τους*, δεδομένου του γεγονότος ότι το buffer μπορεί να είναι αυθαίρετα μικρό. Kάθε λειτουργία αναπαρίσταται από έναν μοναδικό ακέραιο (αντί να στέλνεται πχ. κάθε φορά "/diseaseFrequency", στέλνεται το "5"). Ακολουθεί το μέγεθος του μηνύματος σε bytes και το πραγματικό μήνυμα. Τα ορίσματα των εντολών από τον πατέρα στο παιδί στέλνονται αυτούσια. Ωστόσο, τα αποτελέσματα στέλνονται με κάποια σχετική κωδικοποίηση.
Πχ. το αποτέλεσμα/αναφορά:

"22-12-2020
China
SARS
Age range 0-20 years: 10 cases
Age range 21-40 years: 23 cases
Age range 41-60 years: 34 cases
Age range 60+ years: 45 cases"

θα σταλεί από το παιδί στον πατέρα ως:

"22-12-2020/China/SARS:10:23:34:45;"

και ο πατέρας θα το αποκωδικοποιήσει και θα το εκτυπώσει στην αρχική του μορφή. Έτσι, επιτυγχάνεται μιας μορφής συμπίεση των δεδομένων, χωρίς καμία απώλεια πληροφορίας.

>> Συγχρονισμός Πατέρα-Παιδιών

Πριν μπορέσει να επεξεργαστεί οποιαδήποτε εντολή του χρήστη, ο πατέρας πρέπει να γνωρίζει ότι όλοι οι εργάτες είναι έτοιμοι να δεχτούν κάποιο αίτημα. Αυτό επιτυγχάνεται μέσω ενός προσυμφωνημένου μηνύματος (AVAILABILITY_CHECK) που στέλνεται από τον πατέρα στο παιδί πάνω από το named piped. Στη συνέχεια, ο πατέρας περιμένει ως απάντηση ένα άντιστοιχο μήνυμα από το παιδί (WORKER_READY), προκειμένου να το προσμετρήσει στους έτοιμους εργάτες.


*********************
* Χειρισμός σημάτων *
*********************

Έχει υλοποιηθεί η προτεινόμενη αντιμετώπιση για τα σήματα SIGINT, SIGQUIT, SIGCHLD και SIGUSR1. Επίσης, γίνεται χρήση του σήματος SIGUSR2 ως μηχανισμού επικοινωνίας ανάμεσα στο παιδί και στον πατέρα.

>> Μπλοκάρισμα σημάτων

Τα σήματα στον πατέρα και στο παιδί είναι μπλοκαρισμένα όσο διαρκεί η επεξεργασία μιας εντολής του χρήστη, δηλαδή από τη στιγμή που λαμβάνεται η εντολή, μέχρι και την ολοκλήρωση της. Για τον πατέρα, μια εντολή ολοκληρώνεται με την εμφάνιση του αποτελέσματος (αν υπάρχει) στο stdout.
Για το παιδί, η εντολή ολοκληρώνεται αμέσως μόλις σταλεί *ολόκληρο* το αποτέλεσμα στον πατέρα.

>> Ξεπλοκάρισμα σημάτων

Τα σήματα στον πατέρα λαμβάνονται (ή πιάνονται, αν έχουν ληφθεί κατά τη διάρκεια επεξεργασίας εντολής) ακριβώς πριν ληφθεί η επόμενη εντολή από τον χρήστη. Αν έχει ήδη ληφθεί εντολή, τότε θα πρέπει να περιμένουν την ολοκλήρωσή της.

Τα σήματα στο παιδί λαμβάνονται ή πιάνονται όσο το παιδί περιμένει να διαβάσει κάποια εντολή από τον πατέρα, αλλά δεν έχει *αρχίσει* το διάβασμα. Αν έχει διαβάσει έστω και 1 byte, τότε θα διαβάσει την εντολή, θα ολοκληρώσει την επεξεργασία της και την αποστολή αποτελεσμάτων, και μετά θα εκτελέσει την προκαθορισμένη δράση για το σήμα.

>> Έλεγχος σημάτων

Ο έλεγχος για την έλευση σήματος γίνεται μέσω μεταβλητών-boolean flags και η αντιμετώπισή τους *δεν* γίνεται στους handlers, αλλά στη main.

>> Χρήση σήματος USR2 για IPC

Όταν το παιδί λάβει το σήμα USR1, και αφού ελέγξει για νέα αρχεία, θα συνθέσει ένα μήνυμα με τα αποτελέσματα από τα αρχεία που διάβασε. Προκειμένου να ενημερώσει τον πατέρα ότι έχει ένα διαθέσιμο αποτέλεσμα, στέλνει το σήμα USR2 στον πατέρα, ο οποίος όταν τελειώσει την επεξεργασία της τρέχουσας εντολής, τυπώνει το αποτέλεσμα στο stdout.


Σημείωση: Σε περίπτωση που το πρόγραμμα _δεν_ τερματίσει με SIGKILL/SIGSTOP, απελευθερώνεται *όλη* η μνήμη που έχει δεσμευτεί από τον πατέρα και τα παιδιά.


================================================================================

---------------------------
| Σχετικά με το ερώτημα Β |
---------------------------

Όνομα αρχείου: ./create_infiles.sh

Έχει υλοποιηθεί πλήρως το script που ζητείται.

Μερικές επισημάνσεις:

1) Το <record id> των εγγραφών είναι ένας αύξοντας αριθμός από το 0 μέχρι τον μέγιστο ακέραιο που υποστηρίζει το bash της σχολής (9223372036854775807), οπότε δεν τίθεται θέμα overflow του μετρητή (για μια ρεαλιστική γήινη εφαρμογή).

2) Το bash script δεν παράγει έγκυρες EXIT εγγραφές, δηλαδή όποια εγγραφή EXIT παράγεται, δεν έχει προηγούμενη ENTER. Στην εκφώνηση δεν καθορίζεται κάποια συγκεκριμένη συμπεριφορά.

================================================================================
// EOF
